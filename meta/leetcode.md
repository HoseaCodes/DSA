

| Question   |   Completed      |   Type      |  Algorithm | <p style="text-align: center;">Notes</p>|
|----------| :-------------:|:-------------:|------:|------:|
| [Longest Substring Without Repeating Charactersk](./questions/longestSubstringWORepeating.js) | ✅ Completed | Arrays & Strings  | Sliding Window  | <p style="text-align: justify;">To solve this problem, we can use the hash table and iterate over our term. Let's do two checks on 0 and 1 so as not to waste extra time. Now we can start, we gradually add our letters to the hash table, if it already contains this letter, we delete the letter corresponding to the leftmost index. After that we add our new element. The maximum length is found by comparing our current length with the new one, using Math.max.</p> |
| [String to Integer (atoi)](./questions/stringToInteger.js) |  ✅ Completed |  Arrays & Strings    | Iteration | <p style="text-align: justify;">Turn the string into an array. Create a negative and positive max and return the value if the converted string gets out of bounds. If the converted string is not a number return 0 else return the converted number.</p> |
| [Roman to Integer](./questions/stringToInteger.js) |  ✅ Completed | Arrays & Strings | Iteration | <p style="text-align: justify;">We need to create a hash table, the characters in which will correspond to a certain number. Passing along the line, we will check the current and the next character at once, if the current one is greater than the next one, then everything is fine, we add it to the result (it is initially equal to 0), otherwise, we subtract the current value from the next value (for example, the current 10, and the next 100 , we do 100 - 10, and we get 90), we also add to the result and additionally increase the index by 1. As a result, at the end of the loop, we will get the result we need.</p> |
| [3Sum](./questions/3sum.js) |  ✅ Completed | Arrays & Strings | Two Pointer | <p style="text-align: justify;">First, sort the input array in non-decreasing order. Iterate through the array with a pointer "i" from 0 to n-2, where n is the size of the array. For each "i", initialize two pointers "lo" and "hi", where "lo" starts at i+1 and "hi" starts at n-1. Calculate the sum of elements at i, lo, and hi. If the sum is equal to zero, add the triplet to the result. If the sum is less than zero, increment "lo" to move towards higher values. If the sum is greater than zero, decrement "hi" to move towards lower values. To avoid duplicates, if a value has already been considered, skip it in the future iterations. Continue the above process until all possible triplets are considered.</p> |
| [Remove Duplicates from Sorted Array](./questions/removeDuplicates.js) |  ✅ Completed | Arrays & Strings | Two Pointer | <p style="text-align: justify;">Create an insertIndex(first pointer) then iterate over the sorted number array starting at index 1. If the current index value is not equal to the pervious index value then assign the insertIndex index (nums[insertIndex]) to the current index value and increment the insertIndex value by 1. Essentinally, we hold the index of value that needs to be replaced and when we run into the first value that has not been seen we replace the index of value that needs to be replaced and increase that index. Continue this through the remainder of the array and return the insertIndex.</p>  |
| [Next Permutation](./questions/nextPermutation.js) |  ✅ Completed | Arrays & Strings | Iteration | <p style="text-align: justify;">We loop through the numbers provided from end to start, looking for the first occurrence of a number decreasing, which will be our “left swap”. Next, we again look from right-to-left, until we find a number higher than our left swap, and swap the two numbers round. This effectively gives us the lowest possible “swap” that can be achieved for the given array. <br/> <br/> To give a practical example, given the array ```[7, 2, 3, 1, 5, 4, 3, 2, 0]``` , we can see that the first decrease when looking right-to-left is from 5 to 1, making 1 our left swap. Going right-to-left again, we can then see that the first number higher than our left swap is 2, so we swap them around to give us ```[7, 2, 3, 2, 5, 4, 3, 1, 0]```. <br/> <br/> Next, we sort the numbers to the right of the left-most swapped number to create the lowest possible permutation of the remaining digits. So in the example above, we take the numbers from the right of the moved-over 2, which are ```[5, 4, 3, 1, 0]```, and swap it for its lowest permutation (which we can achieve simply by ordering that array of numbers); ```[0, 1, 3, 4, 5]```. By replacing the original values, this gives us the next greatest permutation of the original number: ```[7, 2, 3, 2, 0, 1, 3, 4, 5]```. <br/> <br/> As another example, let’s take ```[3, 8, 3, 7, 5, 1]```. So, going right-to-left, the first decrease comes at number 3 (index 2), and the first higher number than this, again going right-to-left, is 5, so we swap those around to give us ```[3, 8, 5, 7, 3, 1]```. We then order the numbers on the right of the swapped-over 5 and end up with ```[3, 8, 5, 1, 3, 7]```, which is indeed the next lowest permutation. <br/> <br/> In some cases, there may not actually be the next lowest permutation (for example in the array ```[3, 2, 1]```). In these cases, in line with the question spec, we simply return the lowest permutation, which is easily obtained by ordering the entire array, which gives us ```[1, 2, 3]```.</p> |
| Multiply Strings |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p>  |
| Group Anagrams |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Add Binary |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Minimum Window Substring |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Merge Sorted Array |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Valid Palindrome |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Read N Characters Given Read4 |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Read N Characters Given Read4 II - Call multiple times |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| One Edit Distance  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Product of Array Except Self  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Integer to English Words  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Move Zeroes  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Longest Substring with At Most K Distinct Characters  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Subarray Sum Equals K  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Validate IP Address  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Valid Palindrome II  |  Not Completed | Arrays & Strings |    n/a | <p style="text-align: justify;">Notes</p> |
| Add Two Numbers  |  ✅ Completed | Linked Lists | Elementary Math | <p style="text-align: justify;">Initialize current node to dummy head of the returning list. Initialize carry to 0. Loop through lists l1 and l2 until you reach both ends and carry is 0. Set x to node l1's value. If l1 has reached the end of l1, set to 0. Set y to node l2's value. If l2 has reached the end of l2, set to 0. Set sum = x + y + carry. Update carry = sum / 10. Create a new node with the digit value of (summod10) and set it to current node's next, then advance current node to next. Advance both l1 and l2. Return dummy head's next node.</p> |
| Merge Two Sorted Lists  |  ✅ Completed | Linked Lists | Iteration | <p style="text-align: justify;">First, we set up a false "prehead" node that allows us to easily return the head of the merged list later. We also maintain a prev pointer, which points to the current node for which we are considering adjusting its next pointer. Then, we do the following until at least one of l1 and l2 points to null: if the value at l1 is less than or equal to the value at l2, then we connect l1 to the previous node and increment l1. Otherwise, we do the same, but for l2. Then, regardless of which list we connected, we increment prev to keep it one step behind one of our list heads. <br/><br/> After the loop terminates, at most one of l1 and l2 is non-null. Therefore (because the input lists were in sorted order), if either list is non-null, it contains only elements greater than all of the previously-merged elements. This means that we can simply connect the non-null list to the merged list and return it.</p> |
| Reorder List  |  ✅ Completed | Linked Lists | Iteration | <p style="text-align: justify;">Find a middle node of the linked list. If there are two middle nodes, return the second middle node. Example: for the list 1->2->3->4->5->6, the middle element is 4.<br/><br/>Once a middle node has been found, reverse the second part of the list. Example: convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4.<br/><br/>Now merge the two sorted lists. Example: merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4.<br/><br/>Let's use two pointers, slow and fast. While the slow pointer moves one step forward slow = slow.next, the fast pointer moves two steps forward fast = fast.next.next, i.e. fast traverses twice as fast as slow. When the fast pointer reaches the end of the list, the slow pointer should be in the middle.<br/><br/>Let's traverse the list starting from the middle node slow and its virtual predecessor None. For each current node, save its neighbours: the previous node prev and the next node tmp = curr.next.<br/><br/>While you're moving along the list, change the node's next pointer to point to the previous node: curr.next = prev, and shift the current node to the right for the next iteration: prev = curr, curr = tmp.<br/><br/>Let's pick the first node of each list - first and second, and save their successors. While you're traversing the list, set the first node's next pointer to point to the second node, and the second node's next pointer to point to the successor of the first node. For this iteration the job is done, and for the next iteration move to the previously saved nodes' successors.</p> |
|  Copy List with Random Pointer |  ✅ Completed | Linked Lists | Recursive | <p style="text-align: justify;">Start traversing the graph from head node. If we already have a cloned copy of the current node in the visited dictionary, we use the cloned node reference. If we don't have a cloned copy in the visited dictionary, we create a new node and add it to the visited dictionary. visited_dictionary[current_node] = cloned_node_for_current_node. We then make two recursive calls, one using the random pointer and the other using next pointer. The diagram from step 1, shows random and next pointers in red and blue color respectively. Essentially we are making recursive calls for the children of the current node. In this implementation, the children are the nodes pointed by the random and the next pointers.</p> |
| Validate Binary Search Tree  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Flatten Binary Tree to Linked List  |  Not Completed | Trees and Graphs |  n/a | <p style="text-align: justify;">Notes</p> |
| Binary Tree Maximum Path Sum  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Clone Graph  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Binary Tree Right Side View  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Number of Islands  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Lowest Common Ancestor of a Binary Tree  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Binary Tree Paths  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Alien Dictionary  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Shortest Distance from All Buildings  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Diameter of Binary Tree  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Accounts Merge  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Shortest Distance from All Buildings  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Convert Binary Search Tree to Sorted Doubly Linked List  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Is Graph Bipartite?  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Binary Tree Vertical Order Traversal  |  Not Completed | Trees and Graphs |    n/a | <p style="text-align: justify;">Notes</p> |
| Letter Combinations of a Phone Number  |  ✅ Completed | Recursion |  Backtracking | <p style="text-align: justify;">1. Define a mapping of digits to letters (digitToLetters object) according to the telephone button layout.<br/>2. Create an empty array called result to store all the valid combinations.<br/>3. Define a recursive function called backtrack, which takes two parameters: combination (current combination of letters) and nextDigits (the remaining digits to be processed).<br/>4. In the backtrack function :-<br/>- If there are no more digits to process (nextDigits.length === 0), the current combination is complete, so add it to the result array.<br/>- Otherwise, get the first digit from nextDigits.<br/>- Find the corresponding letters for that digit from the digitToLetters mapping.<br/>- For each letter, call the backtrack function recursively with the updated combination and the remaining digits (excluding the current one).<br/>5. Initialize the recursive function with an empty combination and the input digits string.<br/>6. Return the result array containing all the valid letter combinations.<br/><br/>The backtracking process explores all possible combinations of letters, branching out for each digit and its corresponding letters until all digits are processed. As a result, the code generates all possible letter combinations from the given input digits.</p> |
| Permutations  |  ✅ Completed | Recursion | Backtracking | <p style="text-align: justify;">1. Create a result array.<br/>2. Create a function backtrack with result array, a temp array and the nums array as parameters.<br/>3. In the function, we start a loop for elements of nums.<br/>4. On each iteration, we check if the temp array contains nums, if it does then we continue.<br/>5. Else, we push the current element in the array and call the backtrack function again with the same parameters.<br/>6. Now, the base condition for this recursion is if the temp array's length becoes strictly equal to nums array length, we push the array's shallow clone into the result array and then we return in order to stop the code and start backtracking.<br/>7. The moment we backtrack, we enter the for loop of the previous recursion stack and we remove the last element of that stack from the temp.<br/>8. Again In the next iteration, the temp array will be filled and the process will continue till the iteration of loop ends.</p> |
| Permutations II  |  ✅ Completed | Recursion | Backtracking | <p style="text-align: justify;">1. First sort the array to check for duplicate values<br/>2. First let take an output blank array where we will be putting all the results<br/>3. Loop throuh each elements of the array<br/>4. At each element backtrack such that add that elemnt and inside backtrack add the combinations of other elements<br/>5. For backtracking we take out the element from given array and put it in the tempArr.<br/>6. Agian go to the next element and repeat the same process</p> |
| Remove Invalid Parentheses  |  ✅ Completed | Recursion | BFS | <p style="text-align: justify;">1. Push input string on a queue and also mark it as seen, so we don't look at it again.<br/>2. For each string removed from queue front, check if it is a valid string.<br/>3. If valid, keep looking for other valid strings in the queue.<br/>3. If invalid and a valid string is already found, don't do anything.<br/>4. If invalid and no valid string is found, do the following:<br/>-- For each character of the string, create a substring with all characters but that.<br/>-- If the substring is not seen before, add it to seen and push to queue</p> |
| Regular Expression Matching  |  ✅ Completed | Recursion | Recursive | <p style="text-align: justify;">The basic intuition behind the recursive solution to the regular expression matching problem is to compare the current character in the input string with the current character in the pattern and decide what to do based on the result of the comparison. If the characters match, or if the current character in the pattern is a '.', which matches any character, you can move on to the next character in both the input string and the pattern. If the current character in the pattern is a '*', you have the option of matching zero or more of the preceding element by advancing the input string and the pattern by different amounts.<br/>To implement this intuition, the function uses a recursive approach, in which it calls itself with different combinations of the input string and the pattern to try different possibilities. The base case of the recursion is when the pattern is empty, in which case the input string must also be empty for a match to occur.<br/>The main advantage of this solution is that it is relatively simple and easy to understand, as it follows the intuitive approach of comparing characters and making decisions based on the results of the comparison. However, it has a relatively high time complexity and space complexity, which may make it less suitable for large inputs.To implement regular expression matching with support for '.' and '', you can use a recursive approach. The basic idea is to compare the current character in the input string with the current character in the pattern. If they match, or if the current character in the pattern is a '.', you can move on to the next character in both the input string and the pattern. If the current character in the pattern is a '', you can try matching zero or more of the preceding element by recursively calling the function with the input string and the pattern advanced by different amounts.</p> |
| Subsets  |  ✅ Completed | Recursion | Backtracking | <p style="text-align: justify;">1. Initialize a output array<br/>2. Add subsets to output array.<br/>3. Handle base case.<br/>4. We have two choices on every single element.<br/>- Take the element<br/>- Don't take the element<br/>For example, if nums = [1,2,3], We have 2 choices for 1, another 2 choices for 2, and another 2 choices for 3.</p> |
| Strobogrammatic Number II  |  ✅ Completed | Recursion | Backtracking | <p style="text-align: justify;">1. Answer to be returned and array to be iterated over. Could also have done Object.keys(strobDict) though.<b2/>2. If to only builds up valid strobogramitic numbers when cur.length is reached, just push to ans.<b2/>3. If cur.length >= n / 2 we know what the second half Has to be.<br/>// I.e. - n = 4 and cur === '10', below will run again with '100', then next round '1001'.<b2/>4. This loop builds up the first half of our number.<b2/>5. If !num (I.e. - num === 0) and !cur.length, we skip 0 because '00' for example is invalid.<b2/>6. Here we check to see if next number added will be middle number. If so, we can't use 6 or 9.  161 = 191 when 180'd.  6 and 9 are the only ones banned from mid spot so we skip them.<b2/>7. If above checks all pass, number in consideration is valid so we send it off.</p> |
| Divide Two Integers  |  ✅ Completed | Sorting and Searching | Math | <p style="text-align: justify;">1. Firstly we can easily divide the dividend and the divisor.<br/>2. We use Math.trunc to get rid of the fractional digits.<br/>3. We use Math.min(Math.max(...), -(2 ** 31)) to ensure that the result is within range of a 32-bit signed integer</p> |
| Search in Rotated Sorted Array  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Find First and Last Position of Element in Sorted Array  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Pow(x, n)  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Merge Intervals  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Find Peak Element  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| First Bad Version  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Intersection of Two Arrays  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Intersection of Two Arrays II  |  Not Completed | Sorting and Searching |    n/a | <p style="text-align: justify;">Notes</p> |
| Longest Palindromic Substring  |  Not Completed | Dynamic Programming |    n/a | <p style="text-align: justify;">Notes</p> |
| Longest Valid Parentheses  |  Not Completed | Dynamic Programming |    n/a | <p style="text-align: justify;">Notes</p> |
| Decode Ways  |  Not Completed | Dynamic Programming |    n/a | <p style="text-align: justify;">Notes</p> |
| Best Time to Buy and Sell Stock  |  Not Completed | Dynamic Programming |    n/a | <p style="text-align: justify;">Notes</p> |
| Word Break  |  ✅ Completed | Dynamic Programming |  Top-Down Dynamic Programming  | <p style="text-align: justify;">The given code uses a recursive approach with memoization to solve the problem. The function dp(start) takes a starting index start as its parameter and returns true if the substring of s starting from index start can be segmented into words from the dictionary wordDict.<br/>The function first checks if the starting index start is equal to the length of the input string s. If it is, then it returns true since we have successfully segmented the entire string into words from the dictionary.<br/>If the starting index start has been checked before and it was not possible to segment the substring starting from start into words from the dictionary, we return false immediately, to avoid recomputing the same substring multiple times.<br/>For each starting index start, the code loops through all possible substrings of s starting from start up to n-1, where n is the length of the input string s. If the substring exists in the dictionary wordDict, the function dp() calls itself recursively with the next starting index end as its parameter. If the recursive call returns true, we return true from the current call as well.<br/>Once we have computed the result of dp(0), we can return the result.</p> |
| Range Sum Query 2D - Immutable  |  ✅ Completed | Dynamic Programming | Iterative | <p style="text-align: justify;">1. Create a 2d prefix sum, where prefix[row][col] is the sum of all numbers in the rectangle to the upper left of (row, col).<br/>For each range, we can get the sum by using four prefix sums - one for each corner of the 2d range.</p> |
| Continuous Subarray Sum  |  ✅ Completed | Dynamic Programming | Iterative | <p style="text-align: justify;">Notes</p> |
 

                  


             
                              
